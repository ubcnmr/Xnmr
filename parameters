acq.c:  if (strcmp(data_shm->version,XNMR_ACQ_VERSION) != 0){
acq.c:    printf("data_shm says %s, I say: %s\n",data_shm->version,XNMR_ACQ_VERSION);
acq.c:  if( data_shm->acq_pid > 0 ) {
acq.c:  data_shm->acq_pid = getpid();
acq.c:  pid =  data_shm->ui_pid;
acq.c:  data_shm->acq_sig_ui_meaning = sig;
acq.c:  switch( data_shm->ui_sig_acq_meaning ) {
acq.c:    data_shm->ui_sig_acq_meaning = NO_SIGNAL;
acq.c:    data_shm->ui_sig_acq_meaning = NO_SIGNAL;
acq.c:    //    data_shm->mode = NO_MODE;  //this prevents last accumulation - don't do it
acq.c:    data_shm->ui_sig_acq_meaning = NO_SIGNAL; 
acq.c:      data_shm->pprog_pid = getpid();
acq.c:    strcat(s,data_shm->pulse_exec_path);
acq.c:      strcat(s,data_shm->pulse_exec_path);
acq.c:    //    data_shm->pprog_pid = -1;  // don't do this now - do it in pprog_post_timeout
acq.c:  //printf( "acq: starting pulse program: %s on pid: %d\n", data_shm->pulse_exec_path, (int)pid );
acq.c:  if( data_shm->mode == REPEAT_MODE ) {
acq.c:    for( i=0; i<data_shm->npts*2; i++ )
acq.c:      data_shm->data_image[i] = 0;
acq.c:      for( i=0; i<data_shm->npts*2; i += 2 ) {
acq.c:	data_shm->data_image[ i ] += buffer[i];
acq.c:	data_shm->data_image[ i+1 ] += buffer[i+1];
acq.c:      for( i=0; i<data_shm->npts*2; i += 2 ) {
acq.c:	data_shm->data_image[ i ] -= buffer[i+1]; 
acq.c:	data_shm->data_image[ i+1 ] += buffer[i];
acq.c:      for( i=0; i<data_shm->npts*2; i += 2 ) {
acq.c:	data_shm->data_image[ i ] -= buffer[i]; 
acq.c:	data_shm->data_image[ i+1 ] -= buffer[i+1];
acq.c:      for( i=0; i<data_shm->npts*2; i += 2 ) {
acq.c:	data_shm->data_image[ i ] += buffer[i+1]; 
acq.c:	data_shm->data_image[ i+1 ] -= buffer[i];
acq.c:  pid = data_shm->pprog_pid;
acq.c:    data_shm->pprog_pid = -1; //carl added
acq.c:  pid = data_shm->pprog_pid;
acq.c:      data_shm->pprog_pid=0; //carl added
acq.c:  strcpy(path,data_shm->save_data_path);
acq.c:  if( data_shm->mode == NORMAL_MODE || data_shm->mode == NORMAL_MODE_NOSAVE) {
acq.c:    fprintf( fstream, "%s\n", data_shm->pulse_exec_path );
acq.c:    //    printf("doing save from within acq, dwell: %f\n",data_shm->dwell);
acq.c:	   data_shm->npts, data_shm->npts,data_shm->num_acqs, 
acq.c:	     data_shm->num_acqs_2d,(long unsigned int) 
acq.c:	     (1./data_shm->dwell*1000000),data_shm->dwell);
acq.c:    fprintf( fstream, data_shm->parameters );
acq.c:  data_shm->acqn_2d = 0 ;
acq.c:  data_shm->acqn = 0;
acq.c:  result=sfetch_double( data_shm->parameters,"sf1",&freq,0);
acq.c:  sweep = (int) rint(1.0 / data_shm->dwell*1e6);
acq.c:  result = sfetch_int( data_shm->parameters,"dgain",&dgain,0);
acq.c:  if (data_shm->reset_dsp_and_synth == 1){
acq.c:    data_shm->reset_dsp_and_synth = 0;
acq.c:  data_shm->acqn_2d = 0;
acq.c:    //    printf("inside acq's main while loop, acqn_2d: %i of %i\n",data_shm->acqn_2d,
acq.c:    //	   data_shm->num_acqs_2d);
acq.c:    data_shm->acqn = 0;
acq.c:    for( i=0; i<data_shm->npts*2; i++ )
acq.c:      data_shm->data_image[i] = 0;
acq.c:    while( done == NOT_DONE && ( end_1d_loop == 0 || data_shm->mode == REPEAT_MODE )  ) {
acq.c:      if( done >= 0 && data_shm->acqn_2d == 0 && data_shm->acqn == 0 ) {
acq.c:	result = sched_getparam( data_shm->pprog_pid, &sp );
acq.c:	result = sched_setscheduler(data_shm->pprog_pid,SCHED_FIFO,&sp);
acq.c:	/*	result = sched_getscheduler(data_shm->pprog_pid);
acq.c:		printf("confirmed SCHED_FIFO for pprog, on pid: %i\n",data_shm->pprog_pid); */
acq.c:      if( data_shm->acqn == 0 && data_shm->acqn_2d == 0 && done >= 0 )
acq.c:      data_shm->acqn++;
acq.c:      if (data_shm->acqn == data_shm->num_acqs && (data_shm->mode == NORMAL_MODE
acq.c:						   || data_shm->mode == NORMAL_MODE_NOSAVE)){
acq.c:	data_shm->acqn = 0;
acq.c:	data_shm->acqn_2d++;
acq.c:	if(data_shm->acqn_2d == data_shm->num_acqs_2d){
acq.c:      if (done >=0 && (data_shm->acqn_2d < data_shm->num_acqs_2d || data_shm->mode == REPEAT_MODE )){
acq.c:	// data_shm->acqn,data_shm->acqn_2d);
acq.c:	//	printf( "acq doing acquisition %u of dimension %u\n", data_shm->acqn, data_shm->acqn_2d );
acq.c:	//printf("time is: %f before\n",data_shm->time_per_point);
acq.c:	//	i = scope_read_ints( buffer, data_shm->npts*2, &data_shm->time_per_point, 
acq.c:	//			     data_shm->acqn== 0 || data_shm->mode == REPEAT_MODE ); //fixed 9/26/00
acq.c:	//	printf("time is: %f\n",data_shm->time_per_point);
acq.c:	i = read_fifo(data_shm->npts,buffer);
acq.c:	if( i != data_shm->npts*2  ) {
acq.c:    if( data_shm->mode == NORMAL_MODE || data_shm->mode == NORMAL_MODE_NOSAVE) {
acq.c:      for( i=0; i<data_shm->npts*2; i++ ) {
acq.c:	f = (float) data_shm->data_image[i];
acq.c:  pid = data_shm->pprog_pid;
acq.c:    data_shm->acq_pid = -1;
acq.c:    c = data_shm->pprog_pid;
acq.c:  data_shm->reset_dsp_and_synth = 1; // so that first time we try to do an acquisition, it will happen.
acq.c:  pid = data_shm->ui_pid;
acq.c:  data_shm->acq_sig_ui_meaning = ACQ_LAUNCHED;
acq.c:    kill( data_shm->ui_pid, SIG_UI_ACQ );
acq.c:  pid = data_shm->ui_pid;
acq.c:  data_shm->acq_sig_ui_meaning = ACQ_LAUNCH_FAIL;
acq.c:    kill( data_shm->ui_pid, SIG_UI_ACQ );
acq.c:    printf("acq: sent fail signal put: %i into sig\n",data_shm->acq_sig_ui_meaning);
buff.c:      printf("started up running, signal from acq is: %i\n",data_shm->acq_sig_ui_meaning);
buff.c:      if ( data_shm->acq_sig_ui_meaning != NEW_DATA_READY){
buff.c:  buff->param_set.num_acqs = data_shm->num_acqs;
buff.c:  buff->acq_npts=data_shm->npts;
buff.c:  buff->param_set.num_acqs_2d= data_shm->num_acqs_2d;
buff.c:  //  buff->param_set.dwell = data_shm->time_per_point*1e6;
buff.c:  //  buff->param_set.sw = 1.0/data_shm->time_per_point;
buff.c:  buff->param_set.dwell = data_shm->dwell;
buff.c:  buff->param_set.sw = 1.0/data_shm->dwell*1e6;
buff.c:  if (strcmp(s,data_shm->save_data_path) !=0){
buff.c:    put_name_in_buff(buff,data_shm->save_data_path);
buff.c:  strcpy( buff->param_set.exec_path, data_shm->pulse_exec_path);
buff.c:  strcpy( my_string, data_shm->pulse_exec_path);
buff.c:  load_p_string( data_shm->parameters, data_shm->num_acqs_2d, &buff->param_set );
buff.c:    data_shm->reset_dsp_and_synth = 1;
panel.c:    if (data_shm->mode == NORMAL_MODE)
panel.c:	data_shm->mode = NORMAL_MODE;
panel.c:      else data_shm->mode = NORMAL_MODE_NOSAVE;
panel.c:	strcpy( data_shm->save_data_path, s); 
panel.c:      data_shm->dwell= buffp[current]->param_set.dwell; // this is what the pulse program will use
panel.c:      strcpy( fileN, data_shm->save_data_path );
panel.c:      if( result == 0 ||  data_shm->mode == NORMAL_MODE_NOSAVE) {
panel.c:	if ((int) data == 0 && data_shm->mode == NORMAL_MODE) return 0;
panel.c:	if ((int) data == 1 && data_shm->mode == NORMAL_MODE_NOSAVE) return 0;
panel.c:      data_shm->mode = REPEAT_MODE;  
panel.c:      data_shm->dwell= buffp[current]->param_set.dwell; // this is what the pulse program will use
panel.c:      //      printf("put %f in shm dwell\n",data_shm->dwell);
panel.c:      data_shm->mode = REPEAT_MODE;        
panel.c:      data_shm->dwell= buffp[current]->param_set.dwell; // this is what the pulse program will use
panel.c:      //      printf("put %f in shm dwell\n",data_shm->dwell);
panel.c:    if( data_shm->mode == NORMAL_MODE && data_shm->acq_sig_ui_meaning != ACQ_DONE) {
panel.c:    if( data_shm->mode == NORMAL_MODE_NOSAVE && data_shm->acq_sig_ui_meaning != ACQ_DONE) {
panel.c:    if( data_shm->mode == REPEAT_MODE ) {
panel.c:  data_shm->npts=buffp[current]->acq_npts;
param_f.c:  	  if( data_shm->acqn_2d < param->size)  
param_f.c:				     param->f_val_2d[ data_shm->acqn_2d]);   
param_f.c:    	  if( data_shm->acqn_2d < param->size)  
param_f.c:				     param->i_val_2d[ data_shm->acqn_2d]);  
param_f.c:  	if( data_shm->acqn_2d < current_param_set->parameter[i].size ) 
param_f.c:  				    current_param_set->parameter[i].i_val_2d[ data_shm->acqn_2d ] ); 
param_f.c:  	if( data_shm->acqn_2d < current_param_set->parameter[i].size ) 
param_f.c:  				    current_param_set->parameter[i].f_val_2d[ data_shm->acqn_2d ] ); 
param_f.c:  	data_shm->num_acqs = current_param_set->num_acqs; 
param_f.c:  	data_shm->num_acqs_2d = current_param_set->num_acqs_2d; 
param_f.c:        data_shm->num_acqs = acq_param_set->num_acqs; 
param_f.c:        data_shm->num_acqs_2d = acq_param_set->num_acqs_2d; 
param_f.c:      make_param_string( p_set, data_shm->parameters ); 
param_f.c:    //printf( "new parameter string is:\n%s", data_shm->parameters ); 
param_f.c:  	strcpy( data_shm->pulse_exec_path, current_param_set->exec_path); 
param_f.c:	strcpy(data_shm->save_data_path,current_param_set->save_path); 
param_f.c:	//	printf("send paths: put %s in shm\n",data_shm->save_data_path);
param_f.c:      gtk_entry_set_text( GTK_ENTRY( prog_text_box ), (gchar*)data_shm->pulse_exec_path ); 
param_f.c:      gtk_entry_set_text( GTK_ENTRY( save_text_box ), (gchar*)data_shm->save_data_path ); 
pulse.c:   //   data_shm->pprog_pid = -1;  // don't set this to -1 so that acq knows what to wait() for
pulse.c:   data_shm->pprog_pid = -1; 
pulse.c:   if( data_shm->pprog_pid != getpid() ) { 
pulse.c:   if (strcmp(data_shm->version,XNMR_ACQ_VERSION) != 0){
pulse.c:    strcat(s,data_shm->pulse_exec_path);
pulse.c:      strcat(s,data_shm->pulse_exec_path);
pulse.c:  return data_shm->dwell/1000000.;
pulse.c:  return data_shm->acqn;
pulse.c:  return data_shm->acqn_2d;
pulse.c:  return data_shm->npts;
pulse.c:  return data_shm->num_acqs;
pulse.c:  return data_shm->num_acqs_2d;
pulse.c:  result = sfetch_float( data_shm->parameters, name, var, data_shm->acqn_2d );
pulse.c:  result = sfetch_int( data_shm->parameters, name, var, data_shm->acqn_2d );
pulse.c:  result = sfetch_text( data_shm->parameters, name, var, data_shm->acqn_2d );
pulse.c:  result = sfetch_double( data_shm->parameters, name, var, data_shm->acqn_2d );
pulse.c:   //   data_shm->pprog_pid = -1;  // don't set this to -1 so that acq knows what to wait() for
xnmr.c:      if ( data_shm->ui_pid >0 ){   // pid in shm is valid
xnmr.c:	sprintf(&command[strlen(command)],"%i", data_shm->ui_pid);
xnmr.c:    if ( data_shm->acq_pid > 0){ // there is a valid pid
xnmr.c:      sprintf(&command[strlen(command)],"%i",data_shm->acq_pid);
xnmr.c:    if (data_shm->acq_pid <1 || ic != 0){ 
xnmr.c:	data_shm->acq_pid = -1;
xnmr.c:	printf("about to start acq, ui_pid:%i\n",data_shm->ui_pid);
xnmr.c:    strcpy(buffp[0]->path_for_reload,data_shm->save_data_path);
xnmr_ipc.c:  data_shm->ui_pid = getpid();
xnmr_ipc.c:    //printf( "Xnmr linked into acq that was already running on pid %d\n", data_shm->acq_pid );
xnmr_ipc.c:    strcpy(data_shm->version,XNMR_ACQ_VERSION);
xnmr_ipc.c:    printf("Xnmr: shared memory existed, version string contained: %s\n",data_shm->version);
xnmr_ipc.c:    if (strcmp(data_shm->version,XNMR_ACQ_VERSION) != 0){
xnmr_ipc.c:  //  data_shm->ui_pid = getpid();
xnmr_ipc.c:  strcpy( data_shm->parameters,  "dummy_int = 7\ndummy_float = 5.3\n" );
xnmr_ipc.c:  data_shm->parameter_count = 2;
xnmr_ipc.c:  data_shm->mode = NO_MODE;
xnmr_ipc.c:  data_shm->acq_pid = -1; 
xnmr_ipc.c:  data_shm->pprog_pid = -1;
xnmr_ipc.c:  data_shm->ui_pid = -1;
xnmr_ipc.c:  strcpy ( data_shm->pulse_exec_path, "" );
xnmr_ipc.c:  strcpy ( data_shm->save_data_path, "" );
xnmr_ipc.c:  data_shm->num_acqs = 1;
xnmr_ipc.c:  data_shm->ui_sig_acq_meaning = NO_SIGNAL;
xnmr_ipc.c:  data_shm->acq_sig_ui_meaning = NO_SIGNAL;
xnmr_ipc.c:  pid = data_shm->acq_pid;
xnmr_ipc.c:  c = data_shm->acq_sig_ui_meaning;
xnmr_ipc.c:    c = data_shm->acq_sig_ui_meaning;
xnmr_ipc.c:  data_shm->acq_sig_ui_meaning = NO_SIGNAL;
xnmr_ipc.c:  data_shm->ui_pid = -1;
xnmr_ipc.c:  if (data_shm->ui_pid !=-1) printf("in end_acq and ui_pid = %i\n",data_shm->ui_pid);
xnmr_ipc.c:  //  data_shm->ui_pid = -1;
xnmr_ipc.c:  c = data_shm->acq_pid;
xnmr_ipc.c:  pid =  data_shm->acq_pid;
xnmr_ipc.c:    data_shm->ui_sig_acq_meaning = sig;
xnmr_ipc.c:    sprintf( s, "na %ld / %ld", data_shm->acqn, data_shm->num_acqs);
xnmr_ipc.c:    sprintf( s, "na2 %d / %d", data_shm->acqn_2d+1, data_shm->num_acqs_2d );
xnmr_ipc.c:    sprintf( s, "na %ld / %ld", data_shm->acqn, data_shm->num_acqs );
xnmr_ipc.c:    sprintf( s, "na2 %d / %d", data_shm->acqn_2d+1, data_shm->num_acqs_2d );
xnmr_ipc.c:  /*  if (data_shm->time_per_point < 0){
xnmr_ipc.c:    if( (int) 100*buffp[upload_buff]->param_set.dwell != (int) (100*data_shm->time_per_point*1e6 +1) ){ // how can this ever be?  seems like upload on every scan should pick it up?
xnmr_ipc.c:      // printf("new dwell: %f\n",data_shm->time_per_point*1e6);
xnmr_ipc.c:      buffp[upload_buff]->param_set.dwell=data_shm->time_per_point*1e6;
xnmr_ipc.c:      buffp[upload_buff]->param_set.sw=1.0/data_shm->time_per_point;
xnmr_ipc.c:  sig = data_shm->acq_sig_ui_meaning;
xnmr_ipc.c:  if( sig != ACQ_LAUNCHED ) data_shm->acq_sig_ui_meaning = NO_SIGNAL;
xnmr_ipc.c:	strcpy(buffp[upload_buff]->path_for_reload,data_shm->save_data_path);
xnmr_ipc.c:	if (data_shm->num_acqs_2d == 1 && data_shm->acqn != 0)
xnmr_ipc.c:	       data_shm->acqn,data_shm->num_acqs );
xnmr_ipc.c:	  if (data_shm->mode == NORMAL_MODE){
xnmr_ipc.c:	  data_shm->mode = NO_MODE;
xnmr_ipc.c:	  data_shm->mode = NO_MODE;
xnmr_ipc.c:	  data_shm->mode = NO_MODE;
xnmr_ipc.c:  if( data_shm->acq_sig_ui_meaning != ACQ_LAUNCHED ) {
xnmr_ipc.c:    printf( "Xnmr_ipc recieved an unidentified signal %d\n", data_shm->acq_sig_ui_meaning );
xnmr_ipc.c:    data_shm->acq_sig_ui_meaning = NO_SIGNAL;
xnmr_ipc.c:  /*  if( data_shm->time_per_point > 0 ){
xnmr_ipc.c:    buff->param_set.dwell=data_shm->time_per_point*1000000;
xnmr_ipc.c:    buff->param_set.sw=(long int)1.0/data_shm->time_per_point;
xnmr_ipc.c:  if (data_shm->npts != buff->param_set.npts  || buff->npts2 != 1){
xnmr_ipc.c:    buff_resize(buff,data_shm->npts,1);
xnmr_ipc.c:      update_npts(data_shm->npts);
xnmr_ipc.c:    buff->data[i] = (float)  data_shm->data_image[i];
xnmr_ipc.c:    //printf("%li %f %f\n",data_shm->data_image[i],buff->data[i], (float )data_shm->data_image[i]);
